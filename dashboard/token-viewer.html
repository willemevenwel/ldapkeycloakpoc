<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keycloak Token Viewer - LDAP-Keycloak POC</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .back-link {
            position: absolute;
            top: 30px;
            left: 30px;
            color: white;
            text-decoration: none;
            font-size: 1.2rem;
            transition: opacity 0.3s;
        }

        .back-link:hover {
            opacity: 0.7;
        }

        .content {
            padding: 30px;
        }

        .info-box {
            background: #e7f3fe;
            border-left: 4px solid #2196F3;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ff9800;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .success-box {
            background: #d4edda;
            border-left: 4px solid #4CAF50;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .config-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
        }

        h2 {
            color: #2c3e50;
            margin: 30px 0 15px;
            font-size: 1.8rem;
        }

        h3 {
            color: #34495e;
            margin: 20px 0 10px;
            font-size: 1.4rem;
        }

        label {
            display: block;
            margin: 15px 0 8px;
            font-weight: 600;
            color: #555;
        }

        input, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 10px 5px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .secondary-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .danger-btn {
            background: linear-gradient(135deg, #f44336 0%, #e91e63 100%);
        }

        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            border: 1px solid #ddd;
            font-size: 12px;
        }

        .token-display {
            background: #263238;
            color: #aed581;
            padding: 25px;
            border-radius: 10px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 600px;
            overflow-y: auto;
            line-height: 1.6;
        }

        .claim-highlight {
            color: #ffeb3b;
            font-weight: bold;
        }

        /* Tree view styles */
        .tree-view {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', Consolas, monospace;
            font-size: 13px;
            line-height: 1.6;
            max-height: 600px;
            overflow: auto;
        }

        .tree-item {
            margin-left: 0;
            padding: 2px 0;
        }

        .tree-item.nested {
            margin-left: 20px;
        }

        .tree-key {
            color: #9cdcfe;
            font-weight: 500;
        }

        .tree-string {
            color: #ce9178;
        }

        .tree-number {
            color: #b5cea8;
        }

        .tree-boolean {
            color: #569cd6;
        }

        .tree-null {
            color: #569cd6;
        }

        .tree-bracket {
            color: #d4d4d4;
        }

        .tree-toggle {
            cursor: pointer;
            user-select: none;
            color: #808080;
            margin-right: 5px;
            display: inline-block;
            width: 15px;
        }

        .tree-toggle:hover {
            color: #ffffff;
        }

        .tree-expandable > .tree-key {
            cursor: pointer;
        }

        .tree-expandable > .tree-key:hover {
            text-decoration: underline;
        }

        details summary {
            user-select: none;
        }

        .hidden {
            display: none;
        }

        .token-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .info-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .info-card h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .info-card p {
            color: #666;
            margin: 5px 0;
        }

        .info-card strong {
            color: #333;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e91e63;
        }

        ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        ul li {
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }

            .back-link {
                position: static;
                display: block;
                margin-bottom: 15px;
            }
            
            .token-info-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="position: relative;">
            <a href="index.html" class="back-link">‚Üê Back to Dashboard</a>
            <h1>üîê Keycloak Token Viewer</h1>
            <p>Interactive OAuth2/OIDC Login Flow with JWT Token Inspection</p>
        </div>

        <div class="content">
            <div class="info-box">
                <strong>‚ÑπÔ∏è Purpose:</strong> This tool allows you to test the OAuth2/OIDC authorization code flow with your Keycloak application clients
                and view the JWT tokens with organization and application claims in real-time.
            </div>

            <div class="alert alert-info">
                <strong>‚ÑπÔ∏è How This Works:</strong> First, provide the dashboard client secret to enable API access. 
                Then you can select a realm/client from dropdowns and test user authentication.
                <br><br>
                <strong>Setup Required:</strong> Run <code>./keycloak/configure_dashboard_client.sh &lt;realm-name&gt;</code> to create the dashboard client and get the secret.
            </div>

            <!-- Admin Authentication Section -->
            <div id="adminAuthSection" class="config-section">
                <h2>üîê Step 1: Dashboard Client Configuration</h2>
                <div class="info-box">
                    <strong>‚ÑπÔ∏è Client Credentials:</strong> The dashboard uses a confidential client with client credentials grant 
                    to query the Keycloak Admin API. Paste the client secret below to enable dropdown population.
                    <br><br>
                    <strong>Get Secret:</strong> Run <code>./keycloak/configure_dashboard_client.sh &lt;realm-name&gt;</code> and copy the client secret.
                </div>
                
                <label for="keycloakUrl">Keycloak URL:</label>
                <input type="text" id="keycloakUrl" value="/keycloak" />
                <small style="display: block; margin-top: 5px; color: #7f8c8d;">
                    Using proxied endpoint to avoid CORS issues. External URL: http://localhost:8090
                </small>
                
                <label for="clientSecret">Dashboard Client Secret:</label>
                <input type="password" id="clientSecret" placeholder="Paste dashboard-admin-client secret here" />
                <small style="display: block; margin-top: 5px; color: #7f8c8d;">
                    Client ID: <code>dashboard-admin-client</code> (created by configure_dashboard_client.sh)
                </small>
                
                <button onclick="authenticateWithClientCredentials()">üîë Get API Access Token</button>
                <button onclick="skipAdminAuth()" class="secondary-btn">‚è≠Ô∏è Skip - Enter Manually</button>
                
                <div id="adminAuthError" class="hidden" style="margin-top: 15px; padding: 15px; background: #fee; border-left: 4px solid #f44336; border-radius: 5px; color: #c62828;">
                </div>
            </div>

            <!-- Configuration Section (hidden until admin authenticated) -->
            <div id="configSection" class="config-section hidden">
                <h2>‚öôÔ∏è Step 2: Select Client Configuration</h2>
                <div id="successMessage" class="success-box">
                    <strong>‚úì Admin authenticated successfully!</strong> You can now select a realm and client for testing.
                </div>
                <div id="manualMessage" class="info-box hidden">
                    <strong>‚ÑπÔ∏è Manual Entry Mode:</strong> Enter the realm name and client ID manually below.
                </div>
                
                <label for="realm">Realm:</label>
                <select id="realm" onchange="handleRealmChange()">
                    <option value="">Loading realms...</option>
                </select>
                <input type="text" id="realmManual" class="hidden" placeholder="Enter realm name (e.g., capgemini)" />
                
                <label for="clientId">Client ID:</label>
                <select id="clientId">
                    <option value="">Select a realm first...</option>
                </select>
                <input type="text" id="clientIdManual" class="hidden" placeholder="Enter client ID (e.g., acme-app-a-client)" />
                
                <div id="apiControls" style="margin-top: 15px;">
                    <button onclick="loadRealms()" class="secondary-btn">üîÑ Refresh Configuration</button>
                    <button onclick="logoutAdmin()" class="danger-btn">üö™ Change Admin User</button>
                </div>
                
                <div id="manualControls" class="hidden" style="margin-top: 15px;">
                    <button onclick="switchToApiMode()" class="secondary-btn">üîÑ Try API Mode Again</button>
                </div>
                
                <div class="warning-box">
                    <strong>‚ÑπÔ∏è Note:</strong> This tool uses Direct Access Grants (Resource Owner Password Credentials flow).
                    The selected client must have "Direct Access Grants" enabled in Keycloak.
                    <br><br>
                    Application clients created by <code>configure_application_clients.sh</code> have this enabled by default.
                </div>
            </div>

            <div id="loginSection" class="hidden">
                <h2>üöÄ Step 3: Test User Authentication</h2>
                
                <label for="username">Username:</label>
                <input type="text" id="username" placeholder="e.g., willem or test-acme-admin" />
                
                <label for="password">Password:</label>
                <input type="password" id="password" placeholder="Enter password" />
                
                <button onclick="login()">üîë Login and Get Token</button>
                
                <details style="margin-top: 20px;">
                    <summary style="cursor: pointer; font-weight: bold; padding: 10px; background: #f8f9fa; border-radius: 5px; border: 1px solid #dee2e6;">
                        üìã Show Available Test Users
                    </summary>
                    <div class="info-box" style="margin-top: 10px;">
                        <strong>LDAP Users (from users.csv):</strong><br>
                        ‚Ä¢ <code>willem</code> / <code>willem123P@ssword</code> - ACME & XYZ DS1, XYZ DS2<br>
                        ‚Ä¢ <code>louis</code> / <code>louis123P@ssword</code> - ACME DS2<br>
                        ‚Ä¢ <code>jack</code> / <code>jack123P@ssword</code> - ACME DS1<br>
                        ‚Ä¢ <code>razvan</code> / <code>razvan123P@ssword</code> - ACME DS3<br>
                        ‚Ä¢ <code>andre</code> / <code>andre123P@ssword</code> - XYZ DS2<br>
                        ‚Ä¢ <code>jp</code> / <code>jp123P@ssword</code> - XYZ DS1<br>
                        ‚Ä¢ <code>anwar</code> / <code>anwar123P@ssword</code> - No groups<br><br>
                        
                        <strong>ACME Organization (Keycloak users):</strong><br>
                        ‚Ä¢ <code>test-acme-admin</code> / <code>test-acme-admin</code> - ACME admin role<br>
                        ‚Ä¢ <code>test-acme-developer</code> / <code>test-acme-developer</code> - ACME developer role<br>
                        ‚Ä¢ <code>test-acme-user</code> / <code>test-acme-user</code> - ACME user role<br><br>
                        
                        <strong>XYZ Organization:</strong><br>
                        ‚Ä¢ <code>test-xyz-admin</code> / <code>test-xyz-admin</code> - XYZ admin role<br>
                        ‚Ä¢ <code>test-xyz-developer</code> / <code>test-xyz-developer</code> - XYZ developer role<br>
                        ‚Ä¢ <code>test-xyz-user</code> / <code>test-xyz-user</code> - XYZ user role<br><br>
                        
                        <strong>Multi-Organization:</strong><br>
                        ‚Ä¢ <code>test-multi-org</code> / <code>test-multi-org</code> - Both ACME and XYZ user roles<br><br>
                        
                        <strong>No Organization:</strong><br>
                        ‚Ä¢ <code>test-no-org</code> / <code>test-no-org</code> - Developer role only (no org-specific roles)
                    </div>
                </details>
                
                <div id="loginError" class="hidden" style="margin-top: 15px; padding: 15px; background: #fee; border-left: 4px solid #f44336; border-radius: 5px; color: #c62828;">
                </div>
            </div>

            <div id="tokenSection" class="hidden">
                <h2>‚úÖ Step 4: Token Analysis</h2>
                <div class="success-box">
                    <strong>‚úì Authentication successful!</strong> Your access token has been retrieved and decoded.
                </div>
                
                <div style="margin: 20px 0;">
                    <button onclick="refreshToken()" class="secondary-btn">üîÑ Refresh Token</button>
                    <button onclick="logout()" class="danger-btn">üö™ Logout</button>
                </div>
                
                <div class="token-info-grid" id="tokenInfo"></div>
                
                <h3>üìã JWT Claims Breakdown</h3>
                <div class="info-box">
                    <strong>Key Claims to Understand:</strong>
                    <ul>
                        <li><strong>organization</strong>: The organization identifier (e.g., "acme", "xyz") - hardcoded based on client</li>
                        <li><strong>application</strong>: The application identifier (e.g., "app-a") - hardcoded based on client</li>
                        <li><strong>realm_access.roles</strong>: ALL user's realm roles across all organizations (not filtered!)</li>
                        <li><strong>azp</strong>: Authorized party - the client ID that requested this token</li>
                        <li><strong>preferred_username</strong>: The user's username</li>
                        <li><strong>email</strong>: The user's email address</li>
                    </ul>
                    <br>
                    <strong>‚ö†Ô∏è Important:</strong> Notice that <code>realm_access.roles</code> contains ALL roles the user has, 
                    including roles from other organizations. Your application must filter these roles based on the 
                    <code>organization</code> claim to determine which roles are relevant for the current context.
                </div>
                
                <h3>üîç Decoded JWT Token</h3>
                <div id="decodedToken" class="token-display"></div>
                
                <h3>üìÑ Raw Access Token</h3>
                <pre id="rawToken"></pre>
                
                <div class="info-box" style="margin-top: 20px;">
                    <strong>üí° Client-Side Role Filtering:</strong><br><br>
                    Since Keycloak includes ALL realm roles in the token, your application should filter them like this:<br><br>
                    <code>const orgRoles = token.realm_access.roles.filter(role => role.startsWith(token.organization + '_'));</code>
                </div>
            </div>
        </div>
    </div>

    <script>
        let tokens = null;
        let masterToken = null;

        // No page load handler needed - using direct password grant instead of OAuth redirects

        // Authenticate using client credentials grant (dashboard client)
        async function authenticateWithClientCredentials() {
            const keycloakUrl = document.getElementById('keycloakUrl').value;
            const clientSecret = document.getElementById('clientSecret').value;
            const errorDiv = document.getElementById('adminAuthError');

            if (!clientSecret) {
                errorDiv.textContent = '‚ö†Ô∏è Please enter the dashboard client secret';
                errorDiv.classList.remove('hidden');
                return;
            }

            errorDiv.classList.add('hidden');
            
            try {
                const response = await fetch(`${keycloakUrl}/realms/master/protocol/openid-connect/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        grant_type: 'client_credentials',
                        client_id: 'dashboard-admin-client',
                        client_secret: clientSecret,
                    })
                });

                if (!response.ok) {
                    let errorMessage = `Authentication failed: ${response.status}`;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error_description || errorData.error || errorMessage;
                    } catch (e) {
                        const text = await response.text().catch(() => '');
                        if (text) {
                            errorMessage += ` - ${text.substring(0, 100)}`;
                        }
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json();
                masterToken = data.access_token;

                // Hide admin auth section, show config section
                document.getElementById('adminAuthSection').classList.add('hidden');
                document.getElementById('configSection').classList.remove('hidden');
                document.getElementById('loginSection').classList.remove('hidden');

                // Load realms automatically after successful authentication
                await loadRealms();
            } catch (error) {
                console.error('Client credentials authentication error:', error);
                errorDiv.innerHTML = `‚ùå ${error.message}<br><br>` +
                    `<strong>Troubleshooting:</strong><br>` +
                    `‚Ä¢ Make sure you ran: <code>./keycloak/configure_dashboard_client.sh &lt;realm-name&gt;</code><br>` +
                    `‚Ä¢ Verify the client secret is correct<br>` +
                    `‚Ä¢ Check that Keycloak is running at ${keycloakUrl}`;
                errorDiv.classList.remove('hidden');
                masterToken = null;
            }
        }

        // Skip admin authentication and use manual entry
        function skipAdminAuth() {
            masterToken = null;
            adminCredentials = null;
            
            // Hide admin auth section, show config section in manual mode
            document.getElementById('adminAuthSection').classList.add('hidden');
            document.getElementById('configSection').classList.remove('hidden');
            document.getElementById('loginSection').classList.remove('hidden');
            
            // Switch to manual entry mode
            document.getElementById('successMessage').classList.add('hidden');
            document.getElementById('manualMessage').classList.remove('hidden');
            document.getElementById('realm').classList.add('hidden');
            document.getElementById('realmManual').classList.remove('hidden');
            document.getElementById('clientId').classList.add('hidden');
            document.getElementById('clientIdManual').classList.remove('hidden');
            document.getElementById('apiControls').classList.add('hidden');
            document.getElementById('manualControls').classList.remove('hidden');
            
            // Set default values
            document.getElementById('realmManual').value = 'capgemini';
            document.getElementById('clientIdManual').value = 'acme-app-a-client';
        }

        // Switch back to API mode
        function switchToApiMode() {
            // Show admin auth section again
            document.getElementById('adminAuthSection').classList.remove('hidden');
            document.getElementById('configSection').classList.add('hidden');
            document.getElementById('loginSection').classList.add('hidden');
            
            // Reset to API mode
            document.getElementById('successMessage').classList.remove('hidden');
            document.getElementById('manualMessage').classList.add('hidden');
            document.getElementById('realm').classList.remove('hidden');
            document.getElementById('realmManual').classList.add('hidden');
            document.getElementById('clientId').classList.remove('hidden');
            document.getElementById('clientIdManual').classList.add('hidden');
            document.getElementById('apiControls').classList.remove('hidden');
            document.getElementById('manualControls').classList.add('hidden');
        }

        // Handle realm change - works for both dropdown and manual input
        function handleRealmChange() {
            const realmDropdown = document.getElementById('realm');
            const isHidden = realmDropdown.classList.contains('hidden');
            console.log('handleRealmChange called, dropdown hidden:', isHidden, 'selected realm:', realmDropdown.value);
            
            if (!isHidden) {
                loadClients();
            } else {
                console.log('Realm dropdown is hidden, skipping loadClients()');
            }
        }

        // Clear dashboard client token and return to authentication screen
        function logoutAdmin() {
            masterToken = null;
            
            // Reset form (keep the client secret entered)
            // User might want to reload realms without re-entering secret
            
            // Hide config and login sections, show admin auth
            document.getElementById('adminAuthSection').classList.remove('hidden');
            document.getElementById('configSection').classList.add('hidden');
            document.getElementById('loginSection').classList.add('hidden');
            document.getElementById('tokenSection').classList.add('hidden');
            
            // Reset to API mode
            document.getElementById('successMessage').classList.remove('hidden');
            document.getElementById('manualMessage').classList.add('hidden');
            document.getElementById('realm').classList.remove('hidden');
            document.getElementById('realmManual').classList.add('hidden');
            document.getElementById('clientId').classList.remove('hidden');
            document.getElementById('clientIdManual').classList.add('hidden');
            document.getElementById('apiControls').classList.remove('hidden');
            document.getElementById('manualControls').classList.add('hidden');
            
            // Clear dropdowns
            document.getElementById('realm').innerHTML = '<option value="">Authenticate first...</option>';
            document.getElementById('clientId').innerHTML = '<option value="">Authenticate first...</option>';
        }

        // Get master realm admin token for API calls
        async function getMasterToken() {
            if (masterToken) {
                // Check if token is still valid (basic check)
                try {
                    const decoded = parseJwt(masterToken);
                    if (decoded.exp && decoded.exp * 1000 < Date.now() + 60000) {
                        // Token expires in less than 1 minute, refresh it
                        masterToken = null;
                    }
                } catch (e) {
                    masterToken = null;
                }
            }

            if (masterToken) {
                return masterToken;
            }

            // Re-authenticate using client credentials
            const keycloakUrl = document.getElementById('keycloakUrl').value;
            const clientSecret = document.getElementById('clientSecret').value;
            
            if (!clientSecret) {
                throw new Error('No client secret available. Please authenticate first.');
            }
            
            try {
                const response = await fetch(`${keycloakUrl}/realms/master/protocol/openid-connect/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        grant_type: 'client_credentials',
                        client_id: 'dashboard-admin-client',
                        client_secret: clientSecret,
                    })
                });

                if (!response.ok) {
                    throw new Error(`Failed to refresh master token: ${response.status}`);
                }

                const data = await response.json();
                masterToken = data.access_token;
                return masterToken;
            } catch (error) {
                console.error('Error refreshing master token:', error);
                masterToken = null;
                throw error;
            }
        }

        // Load available realms from Keycloak
        async function loadRealms() {
            const keycloakUrl = document.getElementById('keycloakUrl').value;
            const realmSelect = document.getElementById('realm');
            
            realmSelect.innerHTML = '<option value="">Loading realms...</option>';
            
            try {
                const token = await getMasterToken();
                if (!token) {
                    realmSelect.innerHTML = '<option value="">Please authenticate first</option>';
                    return;
                }

                const response = await fetch(`${keycloakUrl}/admin/realms`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                    }
                });

                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        logoutAdmin();
                        throw new Error('Session expired. Please authenticate again.');
                    }
                    throw new Error(`Failed to load realms: ${response.status}`);
                }

                const realms = await response.json();
                
                // Filter out master realm and populate dropdown
                const userRealms = realms.filter(r => r.realm !== 'master');
                
                if (userRealms.length === 0) {
                    realmSelect.innerHTML = '<option value="">No user realms found</option>';
                    alert('No user realms found. Please create a realm using the setup scripts first.');
                    return;
                }

                realmSelect.innerHTML = '<option value="">Select a realm...</option>';
                userRealms.forEach(realm => {
                    const option = document.createElement('option');
                    option.value = realm.realm;
                    option.textContent = `${realm.realm}${realm.displayName ? ' - ' + realm.displayName : ''}`;
                    if (realm.realm === 'capgemini') {
                        option.selected = true;
                    }
                    realmSelect.appendChild(option);
                });

                // Auto-load clients for the selected realm
                if (realmSelect.value) {
                    await loadClients();
                }
            } catch (error) {
                console.error('Error loading realms:', error);
                realmSelect.innerHTML = '<option value="">Error loading realms</option>';
                alert(`Could not load realms: ${error.message}`);
            }
        }

        // Load available public clients from selected realm
        async function loadClients() {
            const keycloakUrl = document.getElementById('keycloakUrl').value;
            const realm = document.getElementById('realm').value;
            const clientSelect = document.getElementById('clientId');
            
            console.log('loadClients called with realm:', realm);
            
            if (!realm) {
                clientSelect.innerHTML = '<option value="">Select a realm first...</option>';
                return;
            }

            clientSelect.innerHTML = '<option value="">Loading clients...</option>';
            
            try {
                const token = await getMasterToken();
                console.log('Got token for loading clients:', token ? 'yes' : 'no');
                
                if (!token) {
                    clientSelect.innerHTML = '<option value="">Please authenticate first</option>';
                    return;
                }

                const url = `${keycloakUrl}/admin/realms/${realm}/clients`;
                console.log('Fetching clients from:', url);
                
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                    }
                });

                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        logoutAdmin();
                        throw new Error('Session expired. Please authenticate again.');
                    }
                    throw new Error(`Failed to load clients: ${response.status}`);
                }

                const clients = await response.json();
                console.log('Total clients retrieved:', clients.length);
                
                // Filter for clients that support browser-based OAuth flows
                // Include both public clients AND confidential clients with standard flow enabled
                const usableClients = clients.filter(client => 
                    client.enabled &&
                    client.standardFlowEnabled &&
                    !client.bearerOnly && // Exclude bearer-only clients (can't initiate login)
                    client.clientId && 
                    !client.clientId.startsWith('_') &&
                    !client.clientId.endsWith('-dedicated') &&
                    client.clientId !== 'broker' && // Exclude system clients
                    client.clientId !== 'realm-management' &&
                    !client.clientId.startsWith('admin-')
                );

                console.log('Usable clients after filtering:', usableClients.length);
                console.log('Usable client IDs:', usableClients.map(c => c.clientId));

                if (usableClients.length === 0) {
                    clientSelect.innerHTML = '<option value="">No usable clients found</option>';
                    alert('No usable clients found in this realm. Please configure application clients first.');
                    return;
                }

                clientSelect.innerHTML = '<option value="">Select a client...</option>';
                
                // Group clients by type for better organization
                const appClients = usableClients.filter(c => c.clientId.includes('-app-'));
                const sharedClients = usableClients.filter(c => c.clientId.includes('shared-'));
                const otherClients = usableClients.filter(c => !c.clientId.includes('-app-') && !c.clientId.includes('shared-'));

                // Add application clients
                if (appClients.length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = 'üì± Application Clients';
                    appClients.forEach(client => {
                        const option = document.createElement('option');
                        option.value = client.clientId;
                        option.textContent = client.clientId + (client.description ? ` - ${client.description}` : '');
                        optgroup.appendChild(option);
                    });
                    clientSelect.appendChild(optgroup);
                }

                // Add shared clients
                if (sharedClients.length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = 'üåê Shared Clients';
                    sharedClients.forEach(client => {
                        const option = document.createElement('option');
                        option.value = client.clientId;
                        option.textContent = client.clientId + (client.description ? ` - ${client.description}` : '');
                        optgroup.appendChild(option);
                    });
                    clientSelect.appendChild(optgroup);
                }

                // Add other clients
                if (otherClients.length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = 'üîß Other Clients';
                    otherClients.forEach(client => {
                        const option = document.createElement('option');
                        option.value = client.clientId;
                        option.textContent = client.clientId + (client.description ? ` - ${client.description}` : '');
                        optgroup.appendChild(option);
                    });
                    clientSelect.appendChild(optgroup);
                }

                // Auto-select first application client if available
                if (appClients.length > 0) {
                    clientSelect.value = appClients[0].clientId;
                }
            } catch (error) {
                console.error('Error loading clients:', error);
                clientSelect.innerHTML = '<option value="">Error loading clients</option>';
                alert(`Could not load clients: ${error.message}`);
            }
        }

        async function login() {
            const keycloakUrl = document.getElementById('keycloakUrl').value;
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            const errorDiv = document.getElementById('loginError');
            
            // Get realm and clientId from either dropdown or manual input
            let realm, clientId;
            
            if (!document.getElementById('realm').classList.contains('hidden')) {
                // API mode - use dropdowns
                realm = document.getElementById('realm').value;
                clientId = document.getElementById('clientId').value;
            } else {
                // Manual mode - use text inputs
                realm = document.getElementById('realmManual').value;
                clientId = document.getElementById('clientIdManual').value;
            }
            
            if (!realm || !clientId) {
                errorDiv.textContent = '‚ö†Ô∏è Please select both realm and client ID';
                errorDiv.classList.remove('hidden');
                return;
            }
            
            if (!username || !password) {
                errorDiv.textContent = '‚ö†Ô∏è Please enter both username and password';
                errorDiv.classList.remove('hidden');
                return;
            }
            
            errorDiv.classList.add('hidden');
            
            try {
                // First, get the client details to check if it's confidential
                const token = await getMasterToken();
                const clientsResponse = await fetch(`${keycloakUrl}/admin/realms/${realm}/clients`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                    }
                });
                
                const clients = await clientsResponse.json();
                const client = clients.find(c => c.clientId === clientId);
                
                if (!client) {
                    throw new Error(`Client ${clientId} not found in realm ${realm}`);
                }
                
                console.log('Client type:', client.publicClient ? 'public' : 'confidential');
                
                // Use Direct Access Grants (Resource Owner Password Credentials) flow
                const tokenUrl = `${keycloakUrl}/realms/${realm}/protocol/openid-connect/token`;
                console.log('Authenticating to:', tokenUrl);
                
                // Build request body
                const requestBody = {
                    grant_type: 'password',
                    username: username,
                    password: password,
                    client_id: clientId,
                    scope: 'openid profile email'
                };
                
                // Add client secret if it's a confidential client
                if (!client.publicClient && client.secret) {
                    console.log('Using client secret for confidential client');
                    requestBody.client_secret = client.secret;
                }
                
                const response = await fetch(tokenUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams(requestBody)
                });

                if (!response.ok) {
                    let errorMessage = `Authentication failed: ${response.status}`;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error_description || errorData.error || errorMessage;
                    } catch (e) {
                        const text = await response.text().catch(() => '');
                        if (text) {
                            errorMessage += ` - ${text.substring(0, 200)}`;
                        }
                    }
                    throw new Error(errorMessage);
                }

                const tokenData = await response.json();
                console.log('Login successful, got tokens');
                
                // Display the tokens
                displayTokens(tokenData);
                
            } catch (error) {
                console.error('Login error:', error);
                errorDiv.innerHTML = `‚ùå ${error.message}<br><br>` +
                    `<strong>Troubleshooting:</strong><br>` +
                    `‚Ä¢ Verify username and password are correct<br>` +
                    `‚Ä¢ Check that the client has "Direct Access Grants" enabled<br>` +
                    `‚Ä¢ Ensure the user exists in the selected realm`;
                errorDiv.classList.remove('hidden');
            }
        }

        // Render object as tree view
        function renderTreeView(obj, depth = 0) {
            if (obj === null) return `<span class="tree-null">null</span>`;
            if (obj === undefined) return `<span class="tree-null">undefined</span>`;
            
            const type = typeof obj;
            
            if (type === 'string') return `<span class="tree-string">"${obj}"</span>`;
            if (type === 'number') return `<span class="tree-number">${obj}</span>`;
            if (type === 'boolean') return `<span class="tree-boolean">${obj}</span>`;
            
            if (Array.isArray(obj)) {
                if (obj.length === 0) return `<span class="tree-bracket">[]</span>`;
                
                const items = obj.map((item, idx) => {
                    return `<div class="tree-item nested">
                        <span class="tree-key">${idx}:</span> ${renderTreeView(item, depth + 1)}
                    </div>`;
                }).join('');
                
                return `<span class="tree-bracket">[</span>\n${items}\n${'  '.repeat(depth)}<span class="tree-bracket">]</span>`;
            }
            
            if (type === 'object') {
                const keys = Object.keys(obj);
                if (keys.length === 0) return `<span class="tree-bracket">{}</span>`;
                
                const items = keys.map(key => {
                    const highlightKeys = ['organization', 'application', 'realm_access', 'roles', 'preferred_username', 'azp'];
                    const keyClass = highlightKeys.includes(key) ? 'claim-highlight' : 'tree-key';
                    
                    return `<div class="tree-item nested">
                        <span class="${keyClass}">${key}:</span> ${renderTreeView(obj[key], depth + 1)}
                    </div>`;
                }).join('');
                
                return `<span class="tree-bracket">{</span>\n${items}\n${'  '.repeat(depth)}<span class="tree-bracket">}</span>`;
            }
            
            return String(obj);
        }

        function displayTokens(tokenData) {
            // Store tokens globally
            tokens = tokenData;
            
            document.getElementById('loginSection').classList.add('hidden');
            document.getElementById('tokenSection').classList.remove('hidden');
            
            // Display raw access token
            document.getElementById('rawToken').textContent = tokens.access_token;
            
            // Decode and display JWT as tree view
            const decoded = parseJwt(tokens.access_token);
            const treeHtml = `<div class="tree-view">${renderTreeView(decoded)}</div>`;
            document.getElementById('decodedToken').innerHTML = treeHtml;
            
            // Display key information cards
            const orgRoles = decoded.realm_access?.roles?.filter(role => 
                decoded.organization && role.startsWith(decoded.organization + '_')
            ) || [];
            
            const allRoles = decoded.realm_access?.roles || [];
            const nonOrgRoles = allRoles.filter(role => !orgRoles.includes(role));
            
            const info = `
                <div class="info-card">
                    <h4>üë§ User Information</h4>
                    <p><strong>Username:</strong> ${decoded.preferred_username || 'N/A'}</p>
                    <p><strong>Email:</strong> ${decoded.email || 'N/A'}</p>
                    <p><strong>Name:</strong> ${decoded.name || 'N/A'}</p>
                    <p><strong>Subject (ID):</strong> ${decoded.sub || 'N/A'}</p>
                </div>
                
                <div class="info-card">
                    <h4>üè¢ Organization & Application</h4>
                    <p><strong>Organization:</strong> ${decoded.organization || 'N/A'}</p>
                    <p><strong>Application:</strong> ${decoded.application || 'N/A'}</p>
                    <p><strong>Client ID:</strong> ${decoded.azp || 'N/A'}</p>
                    <p><strong>Issuer:</strong> ${decoded.iss || 'N/A'}</p>
                </div>
                
                <div class="info-card">
                    <h4>üé≠ Roles (Organization-Specific)</h4>
                    ${orgRoles.length > 0 ? 
                        `<p>${orgRoles.map(role => `<code>${role}</code>`).join(', ')}</p>` :
                        `<p style="color: #e91e63;"><strong>No organization-specific roles found</strong></p>`
                    }
                </div>
                
                <div class="info-card">
                    <h4>‚ö†Ô∏è Other Roles (Should Filter)</h4>
                    ${nonOrgRoles.length > 0 ? 
                        `<p style="color: #666;">${nonOrgRoles.map(role => `<code>${role}</code>`).join(', ')}</p>
                         <p style="margin-top: 10px; font-size: 0.9em; color: #999;">These roles are included in the token but may not be relevant to the current organization context.</p>` :
                        `<p><strong>None - all roles match organization</strong></p>`
                    }
                </div>
                
                <div class="info-card">
                    <h4>‚è∞ Token Validity</h4>
                    <p><strong>Issued At:</strong> ${new Date(decoded.iat * 1000).toLocaleString()}</p>
                    <p><strong>Expires At:</strong> ${new Date(decoded.exp * 1000).toLocaleString()}</p>
                    <p><strong>Valid For:</strong> ${Math.floor((decoded.exp - decoded.iat) / 60)} minutes</p>
                </div>
                
                <div class="info-card">
                    <h4>üîê Token Details</h4>
                    <p><strong>Token Type:</strong> ${decoded.typ || 'Bearer'}</p>
                    <p><strong>Audience:</strong> ${decoded.aud || 'N/A'}</p>
                    <p><strong>Session ID:</strong> ${decoded.sid || 'N/A'}</p>
                    <p><strong>Scope:</strong> ${decoded.scope || 'N/A'}</p>
                </div>
            `;
            document.getElementById('tokenInfo').innerHTML = info;
            
            // Scroll to token section
            document.getElementById('tokenSection').scrollIntoView({ behavior: 'smooth' });
        }

        function parseJwt(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
                return JSON.parse(jsonPayload);
            } catch (error) {
                console.error('Error parsing JWT:', error);
                return {};
            }
        }

        async function refreshToken() {
            if (!tokens || !tokens.refresh_token) {
                alert('No refresh token available');
                return;
            }

            const keycloakUrl = document.getElementById('keycloakUrl').value;
            const realm = document.getElementById('realm').value;
            const clientId = document.getElementById('clientId').value;

            try {
                const response = await fetch(`${keycloakUrl}/realms/${realm}/protocol/openid-connect/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        grant_type: 'refresh_token',
                        refresh_token: tokens.refresh_token,
                        client_id: clientId,
                    })
                });

                if (!response.ok) {
                    throw new Error(`Token refresh failed: ${response.status}`);
                }

                tokens = await response.json();
                displayTokens();
                alert('‚úì Token refreshed successfully!');
            } catch (error) {
                alert('Error refreshing token: ' + error.message);
                console.error('Token refresh error:', error);
            }
        }

        async function logout() {
            // Clear all tokens and state
            tokens = null;
            masterToken = null;
            
            // Clear form inputs
            document.getElementById('clientSecret').value = '';
            document.getElementById('username').value = '';
            document.getElementById('password').value = '';
            
            // Reset all sections to initial state
            document.getElementById('adminAuthSection').classList.remove('hidden');
            document.getElementById('configSection').classList.add('hidden');
            document.getElementById('loginSection').classList.add('hidden');
            document.getElementById('tokenSection').classList.add('hidden');
            
            // Clear dropdowns
            document.getElementById('realm').innerHTML = '<option value="">Authenticate first...</option>';
            document.getElementById('clientId').innerHTML = '<option value="">Authenticate first...</option>';
            
            // Clear any error messages
            document.getElementById('adminAuthError').classList.add('hidden');
            document.getElementById('loginError').classList.add('hidden');
            
            console.log('Logged out - returning to authentication screen');
        }
    </script>
</body>
</html>
